多线程实现
---
一般来讲多线程服务器中的线程大体可以分为以下三种

 - IO线程
 - 计算线程
 - 第三方线程

IO线程中运行事件循环，调用复用函数，根据fd上发生的不同事件调用对应的处理函数（计算线程）。
计算线程平时阻塞在任务队列上，等待IO线程把任务加入任务队列后开始处理。
第三方线程提供除此之外的服务，比如本程序中使用的日志线程。

本程序中，主线程负责响应client的连接请求，也就是调用accept。收到新连接以后，先通过roundrobin取得某一个子ractor，然后为当前client创建一个新的连接对象，最后使用异步唤醒把它注册到子ractor中。

这里的异步唤醒借鉴于MUDUO库，每个事件循环都有一个Functionvector用来存放别的线程想让本线程执行的函数。具体流程是别的线程调用runInLoop先把函数指针加入到Functionvector，然后使用eventfd让线程从复用函数中返回，依次处理Functionvector中的函数。

ET和LT的取舍
--
我使用的是边缘触发模式，相比于LT模式在高压力下的性能更好，因为可以大幅度减少从复用函数返回的次数，但是在访问相对稀疏的情况下，可能每次都要比LT模式多一次系统调用。

定时器
--
每一个subRector都持有一个定时器，用来处理超时请求。我使用的是stl中的priority_queue，用最小堆维护时间节点，在IO线程中执行心搏函数，从堆中pop出超时连接。相对的缺点是计时并没有十分准确，因为时间节点的超时并不会唤醒事件循环，会导致在访问量比较少的情况下，可能会延迟踢掉某些超时连接。

Rector主要组件
---
事件循环的实现我借鉴了muduo库的设计，重要的类有三个

 - channel：事件分发器，它用来管理某一个fd，保存着处理这个fd所有事件的回调。在poll中维护一个channel和fd的映射，poll把从复用函数中返回的事件的channel返回给事件循环，在事件循环中执行channel的事件处理函数，事件处理函数通过发生的事件执行相应的回调。
 - eventloop：事件循环，它所做的事情基本可以概括为以下步骤：等待复用函数返回channel->处理channel->处理functionvector->执行心搏函数踢掉超时连接->等待复用函数返回channel
 - poll：对复用函数的封装，本程序中使用的是epoll，保存着channel和fd的映射，提供添加，删除，修改channel的接口，外界并不直接接触fd。
 
 日志系统
 ---
 本程序的日志系统详情请看
 https://github.com/chenlujiu/AsyncLogingSystem
